def solve(A):
	# return a list B such that B[0] <= B[1] >= B[2] <= B[3] ...
	# 파이썬에서 Timsort 알고리즘을 쓰는 sort함수의 시간복잡도: O(n log n)
	A.sort()
	# 홀수 자리, 짝수 자리에 있는 원소를 바꾸는 알고리즘은 (n-1)/2 번 반복함. 여기서 시간 복잡도는 상수를 고려하지 않고 n에 대한 복잡도만을 분석하기 때문에 O(n)이라고 표현가능.
	for i in range(1, len(A)-1):
		if i != (len(A)-1) and i%2 == 1:
			A[i], A[i+1] = A[i+1], A[i]
	# 따라서 전체 시간복잡도는 O(n log n) + O(n)이 됨. 일반적으로 복잡도를 분석할 때 가장 높은 차수의 항을 우선적으로 고려하기 때문에 여기서는 O(n lon n)이 가장 높은 차수의 항이므로 결론적으로 시간복잡도는 O(n log n)이 됨.
	return A


# Q. 파이썬에서 sort의 시간복잡도

# A. 파이썬에서 기본적으로 제공하는 sort() 메서드와 내장 함수인 sorted()는 Timsort라는 알고리즘을 사용합니다. Timsort는 일반적인 경우에 대해 매우 효율적인 알고리즘이며, 시간 복잡도는 다음과 같습니다:

# 최악의 경우 시간 복잡도: O(n log n)
# 최선의 경우 시간 복잡도: O(n)
# 평균적인 경우 시간 복잡도: O(n log n)
# Timsort는 데이터의 일부분이 이미 정렬되어 있는 경우 더 빠르게 정렬을 수행할 수 있는 특징이 있습니다. 그래서 최선의 경우(데이터가 이미 정렬되어 있는 경우) 시간 복잡도가 O(n)이 됩니다. 하지만 일반적으로 데이터가 정렬되어 있지 않은 상태에서 정렬을 수행하므로, 평균적인 경우와 최악의 경우 시간 복잡도는 O(n log n)입니다.

# Q. 파이썬에서 리스트의 개수가 n개이고 리스트안에 있는 원소들을 첫번째 원소를 제외하고 두번째 원소와 세번째원소의 자리를 바꾸고 네번째 원소와 다섯번째 원소의 자리를 바꾸는 규칙을 리스트가 끌날 때까지 하는 알고리즘을 짰는데 시간복잡도가 어떻게 돼?

# A. 주어진 문제에서 리스트의 원소들을 첫 번째 원소를 제외하고 나머지 원소들의 자리를 교환하는 알고리즘에 대한 시간 복잡도를 분석해보겠습니다.

# 이러한 작업을 수행하기 위한 파이썬 코드는 다음과 같습니다.

# python
# Copy code
# def swap_elements(lst):
#     for i in range(2, len(lst), 2):
#         lst[i-1], lst[i] = lst[i], lst[i-1]
# 위 코드에서 for 루프는 두 번째 원소부터 시작하여, 리스트의 끝까지 2칸씩 건너뛰며 원소들의 자리를 교환합니다. 이 루프는 리스트의 길이를 n이라 할 때, (n-1)/2 번 반복하게 됩니다. 여기서 상수를 고려하지 않고 n에 대한 복잡도만 분석하기 때문에, O(n)이라고 표현할 수 있습니다.

# 따라서, 주어진 알고리즘의 시간 복잡도는 O(n)입니다.
 

# Q. 그럼 sort함수를 이전에 쓰고 방금 썼던 알고리즘을 같이 쓰면 시간복잡도는 어떻게 돼?

# A.sort() 함수와 위에서 제공한 swap_elements() 알고리즘을 차례로 사용하는 경우, 두 알고리즘의 시간 복잡도를 더해야 합니다.

# 파이썬의 sort() 함수는 Timsort 알고리즘을 사용하며, 평균적인 경우와 최악의 경우 시간 복잡도는 O(n log n)입니다. swap_elements() 알고리즘의 시간 복잡도는 O(n)입니다.

# 두 알고리즘을 차례로 사용하면, 각각의 시간 복잡도를 합산해야 합니다. 따라서 전체 시간 복잡도는 O(n log n) + O(n)이 됩니다. 일반적으로 복잡도를 분석할 때, 가장 높은 차수의 항을 우선적으로 고려합니다. 여기서는 O(n log n)이 가장 높은 차수의 항입니다.

# 그러므로, sort() 함수와 swap_elements() 알고리즘을 함께 사용하는 경우의 시간 복잡도는 O(n log n)입니다.

